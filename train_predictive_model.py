# train_predictive_model.py (Final Corrected Version for KeyError)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import LabelEncoder
import joblib
import os

# Define the path to your log file
LOG_FILE = 'logs/decisions.csv'
MODEL_DIR = 'models' # Define models directory
MODEL_PATH = os.path.join(MODEL_DIR, 'predictive_model.pkl') # Full path for the main model

def train_model():
    # --- Ensure the models directory exists first ---
    os.makedirs(MODEL_DIR, exist_ok=True)
    print(f"Ensured '{MODEL_DIR}' directory exists.")

    print(f"Loading data from {LOG_FILE}...")
    if not os.path.exists(LOG_FILE):
        print(f"Error: {LOG_FILE} not found. Please ensure logs are generated by running main.py.")
        return

    try:
        df = pd.read_csv(LOG_FILE)
        print(f"Loaded {len(df)} entries.")
    except Exception as e:
        print(f"Error reading {LOG_FILE}: {e}")
        return

    # --- Data Preprocessing: RENAME COLUMNS TO MATCH EXPECTATION ---
    column_mapping = {
        'action': 'decision',             # Target variable
        'user_active': 'user_activity',   # Feature
        'network': 'network_status',      # Feature
        'security_risk_score': 'security_risk' # Feature
    }
    df.rename(columns=column_mapping, inplace=True)
    print("Renamed columns to match expected feature names.")


    # Ensure necessary columns exist AFTER renaming
    required_columns = ['cpu_usage', 'battery_level', 'user_activity', 'network_status', 'security_risk', 'decision']
    if not all(col in df.columns for col in required_columns):
        missing_cols = [col for col in required_columns if col not in df.columns]
        print(f"CRITICAL Error: Missing one or more required columns AFTER renaming: {missing_cols}.")
        print(f"Current columns after renaming attempt: {df.columns.tolist()}")
        return

    # Drop rows with any missing values for simplicity
    initial_rows = len(df)
    df.dropna(subset=required_columns, inplace=True)
    if len(df) < initial_rows:
        print(f"Dropped {initial_rows - len(df)} rows with missing values.")

    if len(df) == 0:
        print("No valid data rows left after cleaning. Cannot train model.")
        print("Please ensure your decisions.csv has data and correct column names.")
        return

    # Encode categorical features: 'user_activity' (True/False) and 'network_status' (online/offline)
    # user_activity: Convert True/False to 1/0
    # FIX: Use the RENAMED column 'user_activity'
    df['user_activity_encoded'] = df['user_activity'].astype(int)
    print("Encoded 'user_activity' column.")

    # network_status: Encode 'online'/'offline' to numerical (e.g., 0/1)
    le_network = LabelEncoder()
    df['network_status_encoded'] = le_network.fit_transform(df['network_status'])
    joblib.dump(le_network, os.path.join(MODEL_DIR, 'le_network.pkl')) # Save encoder with full path
    print("Encoded 'network_status' column.")

    # Target variable 'decision': Encode 'Apply'/'Postpone' to numerical (0 or 1)
    le_decision = LabelEncoder()
    df['decision_encoded'] = le_decision.fit_transform(df['decision'])
    joblib.dump(le_decision, os.path.join(MODEL_DIR, 'le_decision.pkl')) # Save encoder with full path
    print("Encoded 'decision' column.")

    # Define features (X) and target (y)
    features = [
        'cpu_usage',
        'battery_level',
        'user_activity_encoded',
        'network_status_encoded',
        'security_risk' # Already numerical
    ]
    X = df[features]
    y = df['decision_encoded']

    if len(X) < 2:
        print("Not enough data to train. Need at least 2 samples.")
        print(f"Current data points: {len(X)}")
        return

    # Check for target variable variance - important for classification
    if len(y.unique()) < 2:
        print(f"Warning: Only one class ({y.unique()[0]}) found in 'decision' column. Model won't learn to differentiate.")
        print("Please ensure your decisions.csv contains both 'Apply' and 'Postpone' actions.")
        # Proceeding anyway for prototype, but model will be trivial if only one class.

    # Split data into training and testing sets
    try:
        if len(y.unique()) > 1:
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)
        else:
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        print(f"Data split into {len(X_train)} training and {len(X_test)} testing samples.")
    except ValueError as e:
        print(f"Error during data split: {e}")
        print("This typically means there aren't enough samples for the test_size or stratification.")
        print(f"Attempting to proceed with full dataset for training (no test set).")
        X_train, y_train = X, y
        X_test, y_test = X, y

    if len(X_train) == 0 or len(y_train) == 0:
        print("Training set is empty after splitting. Cannot train model.")
        return

    # --- Model Training ---
    print("Training Logistic Regression model...")
    model = LogisticRegression(max_iter=1000, solver='liblinear')
    try:
        model.fit(X_train, y_train)
        print("Model training complete.")
        print(f"Training Accuracy: {model.score(X_train, y_train):.2f}")
        if len(X_test) > 0 and len(y.unique()) > 1:
            print(f"Test Accuracy: {model.score(X_test, y_test):.2f}")
        else:
            print("Skipping test accuracy calculation due to insufficient test data or single class.")
        print("Note: Accuracies might be low with limited and randomly generated data, but the model should generate.")
    except Exception as e:
        print(f"Error during model training: {e}")
        print("This often happens if there's no variation in the target variable in the training split (e.g., all 'Apply' or all 'Postpone').")
        print(f"Unique values in y_train: {y_train.unique()}")
        return

    # --- Save the Model ---
    joblib.dump(model, MODEL_PATH)
    print(f"Model saved to {MODEL_PATH}")

if __name__ == "__main__":
    train_model()